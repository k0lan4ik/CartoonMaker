unit Timeline;

interface

uses
  System.Classes, System.SysUtils, System.Types, System.UITypes, System.Generics.Collections,
  System.Math, Vcl.Controls, Vcl.Graphics, Vcl.Forms, Winapi.Windows;

type
  TKeyFrameType = (kftNormal, kftImportant);

  TKeyFrame = class(TCollectionItem)
  private
    FPosition: Cardinal;
    FFrameType: TKeyFrameType;
  published
    property Position: Cardinal read FPosition write FPosition;
    property FrameType: TKeyFrameType read FFrameType write FFrameType;
  end;

  TTrack = class(TCollection)
  private
    FName: string;
    FColor: TColor;
    function GetKeyFrame(Index: Integer): TKeyFrame;
  public
    constructor Create;
    function AddKeyFrame(Pos: Cardinal; FrameType: TKeyFrameType): TKeyFrame;
    property KeyFrames[Index: Integer]: TKeyFrame read GetKeyFrame; default;
  published
    property Name: string read FName write FName;
    property Color: TColor read FColor write FColor;
  end;

  TAnimTimeline = class(TCustomControl)
  private
    FTracks: TObjectList<TTrack>;
    FZoom: Double;
    FScrollX: Integer;
    FCurrentTime: Cardinal;
    FSelectedFrame: TKeyFrame;
    FDragStartPos: TPoint;
    FTrackHeight: Integer;
    FTimeScale: Integer;
    FTimeColor: TColor;
    FGridColor: TColor;
    FTimeFont: TFont;
    FOnTimeChange: TNotifyEvent;

    procedure SetCurrentTime(const Value: Cardinal);
    procedure SetTimeFont(const Value: TFont);
    function XToTime(X: Integer): Cardinal;
    function TimeToX(Time: Cardinal): Integer;
    function FindKeyFrameAt(X, Y: Integer; out TrackIdx: Integer): TKeyFrame;
    procedure DrawTimeRuler;
    function CalculateOptimalTimeStep(RangeMs: Cardinal): Cardinal;
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
   function DoMouseWheel(Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint): Boolean;override;
   public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddTrack(const Name: string; Color: TColor);
    procedure AddKeyFrame(TrackIdx: Integer; Time: Cardinal; FrameType: TKeyFrameType);
    procedure DeleteSelectedFrame;

    property Tracks: TObjectList<TTrack> read FTracks;
  published
    property CurrentTime: Cardinal read FCurrentTime write SetCurrentTime;
    property TimeColor: TColor read FTimeColor write FTimeColor default clBlack;
    property GridColor: TColor read FGridColor write FGridColor default $00CCCCCC;
    property TimeFont: TFont read FTimeFont write SetTimeFont;
    property OnTimeChange: TNotifyEvent read FOnTimeChange write FOnTimeChange;
    property Align;
    property DoubleBuffered;
    property Color;
    property Font;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Animate', [TAnimTimeline]);
end;

{ TTrack }

constructor TTrack.Create;
begin
  inherited Create(TKeyFrame);
end;

function TTrack.AddKeyFrame(Pos: Cardinal; FrameType: TKeyFrameType): TKeyFrame;
begin
  Result := Add as TKeyFrame;
  Result.Position := Pos;
  Result.FrameType := FrameType;
end;

function TTrack.GetKeyFrame(Index: Integer): TKeyFrame;
begin
  Result := Items[Index] as TKeyFrame;
end;

{ TAnimTimeline }

constructor TAnimTimeline.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  ControlStyle := ControlStyle + [csOpaque];
  DoubleBuffered := True;
  Width := 600;
  Height := 200;
  FTrackHeight := 40;
  FZoom := 1.0;
  FTimeScale := 100;
  FTracks := TObjectList<TTrack>.Create(True);

  FTimeColor := clBlack;
  FGridColor := $00CCCCCC;

  FTimeFont := TFont.Create;
  FTimeFont.Name := 'Tahoma';
  FTimeFont.Size := 8;
  FTimeFont.Color := clBlack;
end;

destructor TAnimTimeline.Destroy;
begin
  FTracks.Free;
  FTimeFont.Free;
  inherited;
end;

procedure TAnimTimeline.AddTrack(const Name: string; Color: TColor);
var
  Track: TTrack;
begin
  Track := TTrack.Create;
  Track.Name := Name;
  Track.Color := Color;
  FTracks.Add(Track);
  Invalidate;
end;

procedure TAnimTimeline.AddKeyFrame(TrackIdx: Integer; Time: Cardinal; FrameType: TKeyFrameType);
begin
  if (TrackIdx >= 0) and (TrackIdx < FTracks.Count) then
  begin
    FTracks[TrackIdx].AddKeyFrame(Time, FrameType);
    Invalidate;
  end;
end;

procedure TAnimTimeline.SetCurrentTime(const Value: Cardinal);
begin
  if FCurrentTime <> Value then
  begin
    FCurrentTime := Value;
    Invalidate;
    if Assigned(FOnTimeChange) then FOnTimeChange(Self);
  end;
end;

procedure TAnimTimeline.SetTimeFont(const Value: TFont);
begin
  FTimeFont.Assign(Value);
end;

function TAnimTimeline.TimeToX(Time: Cardinal): Integer;
begin
  Result := Round((Time * FTimeScale * FZoom) - FScrollX);
end;

function TAnimTimeline.XToTime(X: Integer): Cardinal;
begin
  Result := Round((X + FScrollX) / (FTimeScale * FZoom));
end;

procedure TAnimTimeline.DrawTimeRuler;
var
  i, XPos: Integer;
  StartTime, EndTime, TimeStep: Cardinal;
  TimeLabel: string;
  Seconds, Minutes: Integer;
begin
  with Canvas do
  begin
    Pen.Color := FTimeColor;
    Font.Assign(FTimeFont);
    Brush.Style := bsClear;

    // Draw main timeline
    MoveTo(0, 25);
    LineTo(Width, 25);

    StartTime := XToTime(0);
    EndTime := XToTime(Width);
    TimeStep := CalculateOptimalTimeStep(EndTime - StartTime);

    i := StartTime - (StartTime mod TimeStep);
    while i <= EndTime do
    begin
      XPos := TimeToX(i);

      // Grid line
      Pen.Color := FGridColor;
      MoveTo(XPos, 25);
      LineTo(XPos, Height);

      // Time mark
      if i >= StartTime then
      begin
        Pen.Color := FTimeColor;
        MoveTo(XPos, 20);
        LineTo(XPos, 25);

        Minutes := i div 60000;
        Seconds := (i div 1000) mod 60;
        TimeLabel := Format('%2.2d:%2.2d', [Minutes, Seconds]);

        TextOut(XPos - TextWidth(TimeLabel) div 2, 2, TimeLabel);
      end;

      Inc(i, TimeStep);
    end;

    // Current time marker
    Pen.Color := clRed;
    XPos := TimeToX(FCurrentTime);
    MoveTo(XPos, 0);
    LineTo(XPos, Height);
  end;
end;

function TAnimTimeline.CalculateOptimalTimeStep(RangeMs: Cardinal): Cardinal;
begin
  if RangeMs <= 5000 then
    Result := 500
  else if RangeMs <= 15000 then
    Result := 1000
  else if RangeMs <= 30000 then
    Result := 2000
  else if RangeMs <= 60000 then
    Result := 5000
  else
    Result := 10000;
end;

procedure TAnimTimeline.Paint;
var
  i, j: Integer;
  TrackRect, FrameRect: TRect;
  XPos: Integer;
begin
  inherited;

  // Draw background
  Canvas.Brush.Color := Color;
  Canvas.FillRect(ClientRect);

  // Draw time ruler
  DrawTimeRuler;

  // Draw tracks
  for i := 0 to FTracks.Count - 1 do
  begin
    TrackRect := Rect(0, 40 + i * FTrackHeight, Width, 40 + (i+1)*FTrackHeight);

    // Track background
    Canvas.Brush.Color := FTracks[i].Color;
    Canvas.FillRect(TrackRect);

    // Key frames
    for j := 0 to FTracks[i].Count - 1 do
    begin
      XPos := TimeToX(FTracks[i][j].Position);
      FrameRect := Rect(XPos - 8, TrackRect.Top + 4, XPos + 8, TrackRect.Bottom - 4);

      Canvas.Brush.Color := IfThen(FTracks[i][j].FrameType = kftImportant, $00CCFF, clYellow);
      Canvas.Rectangle(FrameRect);
    end;
  end;
end;

function TAnimTimeline.FindKeyFrameAt(X, Y: Integer; out TrackIdx: Integer): TKeyFrame;
var
  i, j, XPos: Integer;
  FrameRect: TRect;
begin
  Result := nil;
  TrackIdx := -1;

  for i := 0 to FTracks.Count - 1 do
  begin
    if (Y >= 40 + i*FTrackHeight) and (Y < 40 + (i+1)*FTrackHeight) then
    begin
      TrackIdx := i;
      for j := 0 to FTracks[i].Count - 1 do
      begin
        XPos := TimeToX(FTracks[i][j].Position);
        FrameRect := Rect(XPos - 8, 40 + i*FTrackHeight + 4, XPos + 8, 40 + (i+1)*FTrackHeight - 4);
        if PtInRect(FrameRect, Point(X, Y)) then
          Exit(FTracks[i][j]);
      end;
    end;
  end;
end;

procedure TAnimTimeline.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  TrackIdx: Integer;
begin
  inherited;
  if Button = mbLeft then
  begin
    FSelectedFrame := FindKeyFrameAt(X, Y, TrackIdx);
    if Assigned(FSelectedFrame) then
    begin
      FDragStartPos := Point(X, Y);
    end
    else if Y < 40 then
    begin
      CurrentTime := XToTime(X);
    end;
  end;
end;

procedure TAnimTimeline.MouseMove(Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  if Assigned(FSelectedFrame) then
  begin
    FSelectedFrame.Position := XToTime(X);
    Invalidate;
  end;
end;

procedure TAnimTimeline.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  FSelectedFrame := nil;
end;

function TAnimTimeline.DoMouseWheel(Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint): Boolean;
var
  OldZoom: Double;
begin
  Result := inherited;
  OldZoom := FZoom;

  if WheelDelta > 0 then
    FZoom := FZoom * 1.1
  else
    FZoom := FZoom / 1.1;

  // Manual range check
  if FZoom < 0.5 then FZoom := 0.5;
  if FZoom > 5.0 then FZoom := 5.0;

  FScrollX := Round(FScrollX * (FZoom / OldZoom));
  Invalidate;
end;

procedure TAnimTimeline.DeleteSelectedFrame;
begin
  // Implementation for frame deletion
end;

end.
