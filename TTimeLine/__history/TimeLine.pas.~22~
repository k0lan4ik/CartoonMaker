unit Timeline;

interface

uses
  System.Classes, System.SysUtils, Vcl.Controls, Vcl.Graphics, Winapi.Windows;

type
  TTimeline = class(TCustomControl)
  private
    { Private declarations }
    FStartTime: Cardinal;     // Начальное значение
    FEndTime: Cardinal;       // Конечное значение
    FCurrentPos: Cardinal;     // Текущая позиция
    FZoom: Double;            // Уровень масштабирования
    FScrollX: Integer;
    FTimeScale: Real;

    FObjectZoneWight: Integer;
    {TimeZone}
    FTimeRulerHeight: Integer;
    FTimeColor: TColor;
    FGridColor: TColor;
    FGridPading: Integer;
    FTimeFont: TFont;
    { События }
    FOnPositionChange: TNotifyEvent;

    { Вспомогательные методы }
    procedure SetCurrentPos(const Value: Cardinal);
    
    
  protected
    { Protected declarations }
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    function DoMouseWheel(Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint): Boolean;


    procedure DrawTimeRuler;
    function CalculateOptimalTimeStep(RangeMs: Cardinal): Cardinal;
    function TimeToX(Time: Cardinal): Integer;
    function XToTime(X: Integer): Cardinal;
    
  public
    { Public declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;


  published
    { Published declarations }
    { Свойства }
    property StartTime: Cardinal read FStartTime write FStartTime default 0;
    property EndTime: Cardinal read FEndTime write FEndTime default 100;
    property CurrentPosition: Cardinal read FCurrentPos write SetCurrentPos default 0;

    { События }
    property OnPositionChange: TNotifyEvent read FOnPositionChange write FOnPositionChange;

    { Наследуемые свойства }
    property Align;
    property Color;
    property DoubleBuffered;
    property Font;
    property ParentColor;
    property ParentFont;
    property PopupMenu;
    property ShowHint;
    property Visible;

    { Наследуемые события }
    property OnClick;
    property OnDblClick;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Custom', [TTimeline]);
end;

{ TTimeline }

constructor TTimeline.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  ControlStyle := ControlStyle + [csOpaque];
  DoubleBuffered := True;
  { Инициализация значений }
  Width := 400;
  Height := 60;
  FStartTime := 0;
  FEndTime := 10000;
  FCurrentPos := 0;
  FZoom := 1; 
  
  FTimeRulerHeight := 30;
  FTimeScale := 0.1;
  FGridPading := 5;
  FGridColor := $00424242;

  FObjectZoneWight := 100;
  
  FTimeColor := clBlack;
  FTimeFont := TFont.Create;
  FTimeFont.Name := 'Tahoma';
  FTimeFont.Size := 8;
  FTimeFont.Color := clBlack;
end;

destructor TTimeline.Destroy;
begin
  inherited Destroy;
end;

function TTimeLine.CalculateOptimalTimeStep(RangeMs: Cardinal): Cardinal;
begin
  if RangeMs <= 5000 then
    Result := 500
  else if RangeMs <= 15000 then
    Result := 1000
  else if RangeMs <= 30000 then
    Result := 2000
  else if RangeMs <= 60000 then
    Result := 5000
  else
    Result := 10000;
end;

function TTimeLine.TimeToX(Time: Cardinal): Integer;
begin
  Result := Round((Time * FTimeScale * FZoom) - FScrollX + FObjectZoneWight);
end;

function TTimeLine.XToTime(X: Integer): Cardinal;
begin
  Result := Round((X + FScrollX - FObjectZoneWight) / (FTimeScale * FZoom));
end;

procedure TTimeLine.DrawTimeRuler;
var
 StartTime, EndTime, TimeStep: Cardinal;
 Seconds, Minutes: Integer;
 TimeLabel: string;
 i, XPos: Integer;
begin
  with Canvas do
  begin
    Pen.Color := FTimeColor;
    Font.Assign(FTimeFont);
    Brush.Style := bsClear;
    
    Rectangle(FObjectZoneWight,0,Width,FTimeRulerHeight);
    MoveTo(FObjectZoneWight, FTimeRulerHeight div 2);
    LineTo(Width, FTimeRulerHeight div 2);

    StartTime := XToTime(FObjectZoneWight);
    EndTime := XToTime(Width);
    TimeStep := CalculateOptimalTimeStep(EndTime - StartTime);
    i := StartTime - (StartTime mod TimeStep); 
    while i <= EndTime do
    begin
      XPos := TimeToX(i);

      Pen.Color := FGridColor;
      MoveTo(XPos, FGridPading);
      LineTo(XPos, FTimeRulerHeight - FGridPading);

       if i >= StartTime then
      begin

        Minutes := i div 60000;
        Seconds := (i div 1000) mod 60;
        TimeLabel := Format('%2.2d:%2.2d', [Minutes, Seconds]);

        TextOut(XPos + 2, 1, TimeLabel);
      end;
      
      Inc(i, TimeStep);
    end;
  end;
end;

procedure TTimeline.Paint;
begin
  inherited;
  with Canvas do
  begin
    { 1. Отрисовка фона }
    Brush.Color := Self.Color;
    FillRect(ClientRect);

    { 2. Отрисовка временной шкалы }
    Pen.Color := clBlack;
    DrawTimeRuler;

    { 3. Отрисовка текущей позиции }
    Pen.Color := clRed;
    MoveTo(TimeToX(FCurrentPos), 0);
    LineTo(TimeToX(FCurrentPos), Height);
  end;
end;

procedure TTimeline.SetCurrentPos(const Value: Cardinal);
begin
  if FCurrentPos <> Value then
  begin
    FCurrentPos := Value;
    Invalidate;
    if Assigned(FOnPositionChange) then FOnPositionChange(Self);
  end;
end;

procedure TTimeline.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  if Button = mbLeft then
    CurrentPosition := XToTime(X);
end;

procedure TTimeline.MouseMove(Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  { Реализация перемещения маркера }
end;

function TTimeline.DoMouseWheel(Shift: TShiftState; WheelDelta: Integer; MousePos: TPoint): Boolean;
begin
  Result := inherited;
  { Реализация масштабирования }
end;

end.
